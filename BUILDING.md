# ymtools のビルドについて

<div style="text-align:right;">
松永　裕介<br>
????.??.?? Ver.1<br>
2013.11.20 Ver.2<br>
2015.03.07 Ver.3<br>
2015.07.22 Ver.3.1<br>
</div>

## はじめに
ymtools は cmake を用いて Makefile の生成を行います．
そのためビルドの流れが以前に比べて単純になりました．
大まかな流れは以下のとおりです．

  1. [ビルドに必要なツールのインストール](#1-ビルドに必要なツールのインストール)
  2. [cmake の実行](#2-cmake-の実行)
  3. [mk_builddir.sh スクリプト](#3-mk_builddirsh-スクリプト)
  4. [do_cmake.sh スクリプト](#4-do_cmakesh-スクリプト)
  5. [make の実行](#5-make-の実行)
  6. [make test の実行](#6-make-test-の実行)
  7. [make install の実行](#7-make-install-の実行)

このうち 1. は PC 上のソフトウェア開発環境を一回インストールすれば以降
は必要ありません．たまにソフトウェアのバージョンアップが必要になるかも
しれません．
2. も通常は最初に一回だけ行えばよいですが，新たにソースファイルを追加
した時などにも実行する必要があります．
3. の mk_builddir.sh スクリプト と 4. の do_cmake.sh スクリプト
は上記の手順を行うシェルスクリプトです．
特に複雑なことはしていませんが，毎回手でコマンドを打ち込むのは
面倒なのでこのようなスクリプトを用意しています．
5. はソースファイルに変更があった時には毎回実行します．
6. は自動テストです．
7. はコンパイルしたバイナリやライブラリ，ヘッダファイルをインストールします．


### ディレクトリ構成
ymtools をコンパイル・インストールする際に以下のような3種類のディレクトリを使います．
- ソースディレクトリ

ソースファイル(git のリポジトリ)があるディレクトリです．
 mk_builddir.sh はここで実行します．

- ビルドディレクトリ

コンパイルを行うディレクトリです．
コンパイル結果のファイルなどがここに生成されます．
cmake コマンドはここで実行します．
cmake コマンドを起動する do_cmake.sh スクリプトも同様です．

- インストールディレクトリ

最終的な実行バイナリやライブラリ，ヘッダファイルがインストールされるディレクトリです．
もちろん，このデイレクトリに対する書き込み許可を持っていなければインストールできません．


##1. ビルドに必要なツールのインストール

ymtools のビルドに必要なツールは以下のとおりです．

- cmake
- gcc/g++ もしくは clang/clang++
- yacc (bison)

あったほうが良いパッケージは以下のとおりです．
- doxygen
- zlib
- libbz2
- liblzma (xz)
- google-perftools
- popt

今回，tcl, python や readline/curses に依存しないようにしました．

以下に個々のツールについて補足します．

- cmake
 現在，FreeBSD-10.1Release の cmake-3.1.3 を用いています．たぶん，
 cmake 3.X なら大丈夫だと思います．

- gcc/g++ もしくは clang/clang++
 現在，FreeBSD-10.1Release の clang-3.4.1 を用いています．
 たぶん gcc-4.7 以降でも動くと思います．

- yacc (bison)
 現在，bison-2.4.3, bison-2.5 でテストしています．
bison を yacc 互換で動かすためには bison -y とします．
bison-1.X.X では %define api.pure ディレクティブを理解してくれないの
で動きません．

- doxygen
  ヘッダファイル中のコメントを元にクラスや関数に関するドキュメントを自動生成する
  プログラムです．どうも Linux のディストリビューションに入っているものは
  バージョンが古いようですが，まだあまり調べていません．

- zlib
  いわゆる gzip 形式の圧縮ライブラリです．普通は標準で入っていると思います．
  FreeBSD 上の zlib-1.2.8 でテストしています．

- libbz2
  bzip2 形式の圧縮ライブラリです．FreeBSD は標準で入っています．
  FreeBSD 上の 1.0.6 でテストしています．
  Linux 系でもパッケージでインストールできると思います．

- liblzma (xz)
  こちらは xz で用いられている圧縮ライブラリです．標準で入っていなくてもパッケージ
  でインストールできると思います．
  FreeBSD 上の lzma-5.0.5 でテストしています．

- google-perftools
  プロファイリングを行うためのライブラリです．旧来の gprof と異なり，google-perftools
  はコンパイル時にプロファイル用のコードを生成する必要がありません．
  実行時にリンクさえできればプロファイルしてくれます．
  ただ，リンク時にリンクしておいたほうが安全なのでこのパッケージが見つかったら
  リンクするようにしています．
  プロファイリングを ON にしない限り，オーバーヘッドはほとんどないと思います．
  FreeBSD の場合は ports/pkg に用意されています．
  2015年8月10日時点でのバージョンは 2.4 です．
  Linux 系もパッケージになっているようですが詳しくは知りません．

- popt
 現在，FreeBSD 上の popt-1.16 でテストしています．


###1.1. 上記ツールがインストールされていない場合の対処

一番簡単なのは，計算機の管理者にいって，上記のツールの最新バージョンを
インストールしてもらうことですが，それが難しい場合には自分でソースをもっ
てきて，configure; make; make install する必要があります．
その場合，ymtools 用のディレクトリを用意してそこにこれら一連のツールを
インストールすることをおすすめします．例えば，ymtools 用に，
`~/proj/ymtools` というディレクトリを用意したとします．
例えば，bison をインストールする際に，bison のソースディレクトリに移って，
~~~shell
$ ./configure --prefix=~/proj/ymtools
$ make
$ make install
~~~
とすれば，`~/proj/ymtools/bin/bison` などがインストールされます．

これら，自分でインストールしたツールを ymtools のビルドに使う場合の指
定の仕方ですが，種類によって違いがあります．

- 実行ファイル
  これは実行時に shell が検索できるように環境変数 PATH に `~/proj/ymtools/bin`
  を加えておいてください．

- ヘッダファイル/ライブラリファイル
  現在，popt のみですが，これは cmake が popt パッケージを見つけるための
  FindPOPT.cmake 中でどう書いてあるかに依存します．
  正直，popt はどうでもいいのであまり調べていません．

別件ですが，YmTools のインストール先を上記のディレクトリと同じにしておくと
いろいろと便利なことがありません．たぶん，実行ファイルやライブラリファイルを
デフォルトで見つけてくれると思います．


###1.1.1 cmake のインストール

Linux 系で一番問題なのが多くのディストリビューションで用意されている cmake
が未だに 2.8 なことです．2015年8月8日時点で最新は 3.3 です．
cmake のダウンロードサイト(http://www.cmake.org/download/)からソース一式
(例えば cmake-3.3.0.tar.gz)を取ってきて，適当な場所に展開し，
```shell
$ ./bootstrap
$ gmake
$ sudo gmake install
```
を実行すれば(たぶん/usr/localの下に)cmake一式がインストールされます．
インストール先を変えたい場合は README.rst を見てください(--prefix オプションを使う)．
ただし，もともとのディストリビューションに古い cmake が含まれていた場合，
新しい cmake をインストールしてだけでは意味がありません．
古い cmake が削除できればいいのですが，
場合によってはパッケージの依存関係がいろいろとあってできない場合もあります．
その時は cmake-3.3 が実行されるように少し工夫が必要になります．
できれば古い cmake がインストールされないようにしておいたほうが無難です．
詳細は次に述べます．


##2. cmake の実行

cmake の仕事は Cコンパイラなどのビルドツールの確認や必要なライブラリの
検索などを行って Makefile を生成することです．
ですのでソースファイルを追加したり，リンクするライブラリを追加したりす
るような Makefile に変更される場合には cmake を実行する必要があります．
逆に，ソースファイルの内容だけが変更された場合には Makefile の変更はあ
りませんので cmake を実行する必要はありません．

cmake はコンパイラやライブラリの場所や名前を巧妙な方法で探します．ライ
ブラリなどをデフォルトの位置にインストールしている場合にはほとんど何の
指定もせずに見つけてくれますが，自分のホームディレクトリの下にインストー
ルした場合などには cmake に位置を教える必要があります．
具体的な方法は cmake のマニュアルで調べてください．
通常，これらの指定は最初の一回だけ行えば，2回め以降は省略可能です．

[***重要***]
cmake はソースディレクトリ上で実行することも可能ですが，ソースディレク
トリはバージョン管理されたファイルが存在しますので，ビルド用の一時ファ
イルやコンパイル結果のファイルなどでソースディレクトリが汚れてしまうこ
とはあまり好ましいことではありません．たとえば git add ./* などとして
しまうと .gitignore で明示的に除外しておかない限りそのディレクトリにあ
るファイルがすべてバージョン管理の対象となってしまいます．
そこで，ビルド用に別のディレクトリを用意し，そこにコンパイル結果のファ
イルを置くことが一般的です．これは automake/autoconf でも同様です．
やりかたは極めて簡単です．今，ソースディレクトリを $(SRC_DIR) ビルドディ
レクトリを $(BUILD_DIR) とします．すると cmake の実行は以下のような手
順で行います．
~~~shell
$ mkdir -p $(BUILD_DIR)
$ cd $(BUILD_DIR)
$ cmake $(SRC_DIR)
~~~
これで $(BUILD_DIR) 以下に Makefile といくつかの作業用ディレクトリが生
成されます．
上に述べたように `/usr/bin/cmake` が cmake-2.8 で `/usr/local/bin/cmake`
が cmake-3.3 だった場合には上の `cmake` のところを `/usr/local/bin/cmake`
に置き換えてください．
実行パスの PATH を修正して /usr/local/bin を /usr/bin よりも前に持ってくる
という手もありますが，あまり良い対処法とは思えません．


##3. mk_builddir.sh スクリプト

ビルドディレクトリの用意と毎回の cmake の実行を行うスクリプトの生成
を行うためのスクリプトを作りました．
ソースディレクトリで
~~~
$ mk_builddir.sh <ビルドディレクトリ> <インストールディレクトリ>
~~~
を実行すると
~~~
****
source  directory: XXX
build   directory: XXX
install directory: XXX
****
continue with above configuration ? (yes/no):
~~~
という表示が出ますので問題なければ yes と入力してください．
その後，<ビルドディレクトリ>　直下に do_cmake.sh というシェルスクリプト
が生成されます．
次に，ビルドディレクトリに移動して
~~~
$ ./do_cmake.sh
~~~
を実行してください．
通常はこのスクリプトは最初の一回だけ実行すればよいです．
ビルドディレクトリをまっさらにしてやり直す場合などに再実行します．


##4. do_cmake.sh スクリプト

do_cmake は簡単なシェルスクリプトで毎回同じ cmake の引数を手でタイプ
しなくて済むためのものです．cmake の引数にオプションを加えたい場合は
直接 cmake コマンドを手で入力するか do_cmake スクリプトを書き換えて
ください．

上に書きましたが，古い cmake と新しい cmake が存在している場合，
ここで新しい cmake を起動しなければなりません．
そのためには `CMAKE` という環境変数に新しい cmake のパスを入れておけばOKです．
たとえば `/usr/local/bin/cmake` に cmake-3.3.0 がインストールされているとすると，
```shell
$ env CMAKE=/usr/local/bin/cmake ./do_cmake.sh
```
で新しい cmake を使ってくれます．
もしくは sh(bash) 系のシェルの場合は
```shell
$ export CMAKE=/usr/local/bin/cmake
```
を実行しておけば `env CMAKE=...` の部分は不要になります．
csh(tcsh) 系のシェルの場合は
```csh
% setenv CMAKE /usr/local/bin/cmake
```
です．

また，cmake 実行時(do_cmake.sh実行時)に環境変数 `CC` および `CXX` をセットしておくと
Cコンパイラ/C++コンパイラを指定することができます．
例えば `/usr/local/bin/clagn34`, `/usr/local/bin/clang++34`をそれぞれCコンパイラ/C++コンパイラ
として使いたい場合(実はYmToolsではC++のみを使う)には，
```shell
$ env CC=/usr/local/bin/clang34 CXX=/usr/local/bin/clang++34 ./do_cmake.sh
```
を実行すればOKです．環境変数の設定は上と同様に `export` 文で一回設定してしまってもOKです．
`env` 文はその行のコマンド実行のみに環境変数が設定されます．

通常はこの do_cmake.sh スクリプトは一回，実行するだけで良いのですが，
ソースファイルを追加したり，リンクするライブラリを追加した場合
(つまり CMakeLists.txt を変更した場合)には Makefile を作りなおす必要が
ありますのでこの do_cmake.sh を再実行してください
(というか複数回，実行することのないものをスクリプトにはしません)．
ただし，cmake が巧妙に Makefile を作ってくれるので
CMakeLists.txt を変更した場合に make を実行すると
cmake を実行してくれます．


##5. make の実行

cmake で問題が起こっていない限りあとは make とタイプするだけですべての
ビルドが完了します．
ソースファイルに変更を加えただけなら cmake の実行は必要ありません．
make だけでOKです．


##6. make test の実行

まだすごく不十分ですが，テストコードを作っています．
make が終わったら
~~~shell
$ make test
~~~
で各ライブラリのテストを行ってください．
現在は CTest (cmake のテストツール)と google-test ライブラリを用いて
います．このような枠組みは CppUnit とか CppUtest とかいろいろあって
いろいろ試しているのですが，現在は CTest と google-test になっています．
具体的には個々のライブラリのディレクトリ直下に gtest というディレクトリ
があってその下にテスト用のバイナリがあります．
それを直接実行すると詳細なテスト出力が読めます．


##7. make install の実行

エラーがなければ最後に

~~~
$ make install
~~~

を実行すればインストールディレクトリにファイルがインストールされます．
インストールディレクトリが存在しない場合，作成されますのでスペルミスする
とエラーとならずに新しいディレクトリを作ってしまうので注意してください．
