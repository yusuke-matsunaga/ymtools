
/// @file FileIOTest.cc
/// @brief FileIOTest の実装ファイル
/// @author Yusuke Matsunaga (松永 裕介)
///
/// Copyright (C) 2015 Yusuke Matsunaga
/// All rights reserved.


#include "gtest/gtest.h"
#include "YmUtils/FileIDO.h"
#include "YmUtils/FileODO.h"
#include "YmUtils/MsgMgr.h"
#include "YmUtils/MsgHandler.h"


BEGIN_NAMESPACE_YM

class FileIOTest :
  public testing::TestWithParam<CodecType>
{
public:

  // コンストラクタ
  FileIOTest();

  // デストラクタ
  virtual
  ~FileIOTest();


private:

  StreamMsgHandler mMH;

};

FileIOTest::FileIOTest() :
  mMH(&cout)
{
  MsgMgr::reg_handler(&mMH);
}

FileIOTest::~FileIOTest()
{
}

TEST_P(FileIOTest, ODO_auto_close)
{
  CodecType codec_type = GetParam();

  // open() のみでデストラクタで自動的に close() されるかテスト
  {
    FileODO ofd(codec_type);
    ASSERT_TRUE( ofd.open("test.dat") ) << "Could not open file";
    ofd.write_32(0);
  }
}

TEST_P(FileIOTest, rw_8)
{
  ymuint8 data_list[] = {
    0xFF, 0x00, 0xAA, 0x55
  };

  CodecType codec_type = GetParam();

  ymuint n = sizeof(data_list) / sizeof(ymuint8);

  {
    FileODO ofd(codec_type);
    ASSERT_TRUE( ofd.open("test.dat") ) << "Could not open file";

    for (ymuint i = 0; i < n; ++i) {
      ofd.write_8(data_list[i]);
    }
  }

  {
    FileIDO ifd(codec_type);
    ASSERT_TRUE( ifd.open("test.dat") ) << "Could not open file";

    for (ymuint i = 0; i < n; ++ i) {
      ymuint8 val1 = ifd.read_8();
      EXPECT_EQ( data_list[i], val1 );
    }
  }
}

TEST_P(FileIOTest, rw_misc)
{
  const ymuint8  data1 = 0x01U;
  const ymuint16 data2 = 0xFEDCU;
  const ymuint32 data3 = 0xABCD9876UL;
  const ymuint64 data4 = 0x0123456789ABCDEFULL;

  CodecType codec_type = GetParam();

  {
    FileODO ofd(codec_type);
    ASSERT_TRUE( ofd.open("test.dat") ) << "Could not open file";

    ofd.write_8(data1);
    ofd.write_16(data2);
    ofd.write_32(data3);
    ofd.write_64(data4);
  }

  {
    FileIDO ifd(codec_type);
    ASSERT_TRUE( ifd.open("test.dat") ) << "Could not open file";

    ymuint8 val1 = ifd.read_8();
    EXPECT_EQ( data1, val1 );

    ymuint16 val2 = ifd.read_16();
    EXPECT_EQ( data2, val2 );

    ymuint32 val3 = ifd.read_32();
    EXPECT_EQ( data3, val3 );

    ymuint64 val4 = ifd.read_64();
    EXPECT_EQ( data4, val4 );

  }
}

TEST_P(FileIOTest, rw_float)
{
  const float data_list[] = {
    0.0, 1.0, 1.23456789, 9.8765432e-30
  };

  CodecType codec_type = GetParam();

  ymuint n = sizeof(data_list) / sizeof(float);

  {
    FileODO ofd(codec_type);
    ASSERT_TRUE( ofd.open("test.dat") ) << "Could not open file";

    for (ymuint i = 0; i < n; ++ i) {
      ofd.write_float(data_list[i]);
    }
  }

  {
    FileIDO ifd(codec_type);
    ASSERT_TRUE( ifd.open("test.dat") ) << "Could not open file";

    for (ymuint i = 0; i < n; ++ i) {
      float val1 = ifd.read_float();
      EXPECT_EQ( data_list[i], val1 ) << "data_list[" << i << "]";
    }
  }
}

TEST_P(FileIOTest, rw_double)
{
  const double data_list[] = {
    0.0, 1.0, 1.23456789, 9.8765432e-30
  };

  CodecType codec_type = GetParam();

  ymuint n = sizeof(data_list) / sizeof(double);

  {
    FileODO ofd(codec_type);
    ASSERT_TRUE( ofd.open("test.dat") ) << "Could not open file";

    for (ymuint i = 0; i < n; ++ i) {
      ofd.write_double(data_list[i]);
    }
  }

  {
    FileIDO ifd(codec_type);
    ASSERT_TRUE( ifd.open("test.dat") ) << "Could not open file";

    for (ymuint i = 0; i < n; ++ i) {
      double val1 = ifd.read_double();
      EXPECT_EQ( data_list[i], val1 ) << "data_list[" << i << "]";
    }
  }
}

TEST_P(FileIOTest, rw_string)
{
  const char* data_list[] = {
    "",
    "abc",
    "a quick fox jumped over a lazy sheep"
  };

  CodecType codec_type = GetParam();

  ymuint n = sizeof(data_list) / sizeof(const char*);

  {
    FileODO ofd(codec_type);
    ASSERT_TRUE( ofd.open("test.dat") ) << "Could not open file";

    for (ymuint i = 0; i < n; ++ i) {
      ofd.write_str(data_list[i]);
    }
  }

  {
    FileIDO ifd(codec_type);
    ASSERT_TRUE( ifd.open("test.dat") ) << "Could not open file";

    for (ymuint i = 0; i < n; ++ i) {
      string val1 = ifd.read_str();
      EXPECT_EQ( data_list[i], val1 ) << "data_list[" << i << "]";
    }
  }
}

INSTANTIATE_TEST_CASE_P(AllFileIo, FileIOTest, testing::ValuesIn(get_codec_type_list()));

END_NAMESPACE_YM
